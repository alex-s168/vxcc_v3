included_only

extensible class Op(
    string args,
    string debug
    string descr,

    usize  inlineCost,
    usize  execCost,
    bool   endsFlow,
    bool   hasEffect,
    bool   volatile,
    bool   sideEffect,

    # boolean inverse (NOT on the result will be replaced by the inverse op if present)
    ?Op    inverse,

    # when this is true, pattern matching will succeed if VX_IR_NAME_A and VX_IR_NAME_B is swapped
    bool   commutative = false,
)

extensible enum Ops : Op
{
    IMM(args="val: variable",
        debug="imm",
        descr="copy value from src var to out0 var",
        inlineCost=1,
        execCost=1,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    ZEROEXT(
        args="val: value",
        debug="zx",
        descr="zero-extends the given value to the result type",
        inlineCost=1,
        execCost=1,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    SIGNEXT(
        args="val: value",
        debug="sx",
        descr="sign-extends the given value to the result type",
        inlineCost=1,
        execCost=1,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    TOFLT(
        args="val: value",
        debug="toflt",
        descr="converts the given integer to a float",
        inlineCost=1,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    FROMFLT(
        args="val: value",
        debug="fromflt",
        descr="converts the given float to an integer",
        inlineCost=1,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    FLTCAST(
        args="val: value",
        debug="fltcast",
        descr="converts between two different floating point formats / sizes",
        inlineCost=1,
        execCost=4,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    BITCAST(
        args="val: value",
        debug="bitcast",
        descr="reinterpret the bits of the given value as a different type",
        inlineCost=1,
        execCost=1,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    LOAD(
        args="addr: value",
        debug="load",
        descr="load T from memory at the given address , T = type of output variable" ,
        inlineCost=2,
        execCost=5,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    LOAD_VOLATILE(
        args="addr: value",
        debug="vload",
        descr="load T from volatile memory at the given address , T = type of output variable" ,
        inlineCost=2,
        execCost=5,
        endsFlow=false,
        hasEffect=true,
        volatile=true,
        sideEffect=true,
    ),

    STORE(
        args="addr: value, val: value",
        debug="store",
        descr="store the given value into memory at the given address",
        inlineCost=2,
        execCost=5,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=true,
    ),

    STORE_VOLATILE(
        args="addr: value, val: value",
        debug="vstore",
        descr="store the given value into volatile memory at the given address",
        inlineCost=2,
        execCost=5,
        endsFlow=false,
        hasEffect=true,
        volatile=true,
        sideEffect=true,
    ),

    PLACE(
        args="var: variable",
        debug="place",
        descr="force the given variable to be in memory (typically on the stack) and returns the address to that variable.",
        inlineCost=1,
        execCost=1,
        endsFlow=false,
        hasEffect=false,
        volatile=false,
        sideEffect=false,
    ),

    LOAD_EA(
        args="ptr, idx, elsize",
        debug="load-ea",
        descr="combined ea and load",
        inlineCost=3,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    STORE_EA(
        args="val, ptr, idx, elsize",
        debug="store-ea",
        descr="combined ea and store",
        inlineCost=3,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=true,
    ),

    ADD(args="a: value, b: value",
        debug="add",
        descr="add the two given integer or float numbers together ; both values have to have the same type as the output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        commutative=true,
    ),

    SUB(args="a: value, b: value",
        debug="sub",
        descr="subtract the float or integer b from the float or intege a ; both values have to have the same type as the output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    MUL(args="a: value, b: value",
        debug="mul",
        descr="multiply the two given integer or float numbers together ; both values have to have the same type as the output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        commutative=true,
    ),

    UDIV(
        args="a: value, b: value",
        debug="udiv",
        descr="divide a / b ; unsigned int ; the output type has to be a unsigned integer ; both values have to have the same type as the output type",
        inlineCost=1,
        execCost=4,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    SDIV(
        args="a: value, b: value",
        debug="sdiv",
        descr="divide a / b ; signed int ; the output type has to be a signed integer ; both values have to have the same type as the output type",
        inlineCost=1,
        execCost=4,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    FDIV(
        args="a: value, b: value",
        debug="fdiv",
        descr="divide a / b ; float ; the output type has to be a floating point number ; both values have to have the same type as the output type",
        inlineCost=1,
        execCost=5,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    UMOD(
        args="a: value, b: value",
        debug="umod",
        descr="(unsigned) modulus a % b ; both values have to have the same type as the output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    SMOD(
        args="a: value, b: value",
        debug="smod",
        descr="(signed) modulus a % b ; both values have to have the same type as the output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    UGT(args="a: value, b: value",
        debug="ugt",
        descr="compare unsigned a > b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=ULTE,
    ),

    UGTE(
        args="a: value, b: value",
        debug="ugte",
        descr="compare unsigned a >= b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=ULT,
    ),

    ULT(args="a: value, b: value",
        debug="ult",
        descr="compare unsigned a < b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=UGTE,
    ),

    ULTE(
        args="a: value, b: value",
        debug="ulte",
        descr="compare unsigned a <= b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=UGT,
    ),

    SGT(args="a: value, b: value",
        debug="sgt",
        descr="compare signed a > b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=SLTE,
    ),

    SGTE(
        args="a: value, b: value",
        debug="sgte",
        descr="compare signed a >= b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=SLT,
    ),

    SLT(args="a: value, b: value",
        debug="slt",
        descr="compare signed a < b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=SGTE,
    ),

    SLTE(
        args="a: value, b: value",
        debug="slte",
        descr="compare signed a <= b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=SGT,
    ),

    EQ( args="a: value, b: value",
        debug="eq",
        descr="compare a == b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=NEQ,
        commutative=true,
    ),

    NEQ(args="a: value, b: value",
        debug="neq",
        descr="compare a != b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=EQ,
        commutative=true,
    ),

    AND(args="a: value, b: value",
        debug="and",
        descr="boolean a && b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        commutative=true,
    ),

    OR( args="a: value, b: value",
        debug="or",
        descr="boolean a || b ; both values have to have the same type ; output type can be different (boolean)",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        commutative=true,
    ),

    BITWISE_AND(
        args="a: value, b: value",
        debug="bwand",
        descr="bitwise a & b ; both values have to have the same type as output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        commutative=true,
    ),

    BITIWSE_OR(
        args="a: value, b: value",
        debug="bwor",
        descr="bitwise a | b ; both values have to have the same type as output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        commutative=true,
    ),

    SHL(args="a: value, b: value",
        debug="shl",
        descr="a << b ; both values have to have the same type as output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    SHR(args="a: value, b: value",
        debug="shr",
        descr="a >> b ; both values have to have the same type as output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    ASHR(
        args="a: value, b: value",
        debug="ashr",
        descr="arithmetic a >> b ; both values have to have the same type as output type",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    NEG(args="val: value",
        debug="neg",
        descr="negate the given value ; value has to have same type as output",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    NOT(args="val: value",
        debug="not",
        descr="boolean not the given value ; value does not have to have same type as output",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
        inverse=IMM,
    ),
                         
    BITWISE_NOT(
        args="val: value",
        debug="not",
        descr="bitwise not the given value ; value has to have same type as output",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    BITMASK(
        args="idx: value",
        debug="bitmask",
        descr="generate a mask that corresponds to the bit at the given index ; identical to 1 << idx ; value has to have same type as output",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    BITEXTRACT(
        args="val: value, idx: value",
        debug="bit-extract",
        descr="bitmask(idx) & value",
        inlineCost=2,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    BITPOPCNT(
        args="val: value",
        debug="popcnt",
        descr="count the set bits in the given number ; output type can be different from input",
        inlineCost=8,
        execCost=10,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    BITTZCNT(
        args="val: value",
        debug="tzcnt",
        descr="count the amount of trailing zero bits",
        inlineCost=8,
        execCost=10,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    BITLZCNT(
        args="val: value",
        debug="lzcnt",
        descr="count the amount of leading zero bits",
        inlineCost=8,
        execCost=10,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    FOR(
        args="start: varlue, cond: (counter,states..)->continue?, stride: value, do: (counter,states..)->states, states..",
        debug="for",
        descr="for loop ; stride can be negative ; states are initialized at begin ; every iter states passed into do block and output of do block overwrites states",
        inlineCost=3,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    INFINITE(
        args="start: value, stride: value, do: (counter,states..)->states, states..",
        debug="infinite",
        descr="repeat forever ; can contain break and continue ; stride can be negative ; states are initialized at begin ; every iter states passed into do block and output of do block overwrites states",
        inlineCost=3,
        execCost=3,
        endsFlow=true,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    CONTINUE(
        args="states..",
        debug="continue",
        descr="stop this loop iteration and continue with the next ; set the states to the args",
        inlineCost=3,
        execCost=3,
        endsFlow=true,
        hasEffect=true,
        volatile=false,
        sideEffect=true,
    ),

    BREAK(
        args="states..",
        debug="break",
        descr="stop the loop ; set the states to the args",
        inlineCost=3,
        execCost=3,
        endsFlow=true,
        hasEffect=true,
        volatile=false,
        sideEffect=true,
    ),

    RETURN(
        args="returns..",
        debug="ret",
        descr="early return frm root block",
        inlineCost=3,
        execCost=3,
        endsFlow=true,
        hasEffect=true,
        volatile=false,
        sideEffect=true,
    ),

    WHILE(
        args="cond: (States)->bool, do: (counter, States)->States, States",
        debug="while",
        descr="while loop",
        inlineCost=3,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    REPEAT(
        args="start: counter, endEx: counter, stride: int, do: (counter, States)->States, States",
        debug="repeat",
        descr="for range loop",
        inlineCost=4,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    CFOR(
        args="start: ()->., cond: ()->bool, end: ()->., do: (counter)->.",
        debug="cfor",
        descr="C-like for-loop (only in CIR)",
        inlineCost=4,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    IF(
        args="cond: bool, then: ()->R, (else: ()->R)",
        debug="if",
        descr="if",
        inlineCost=3,
        execCost=3,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    CMOV(
        args="cond: bool, then: value, else: value",
        debug="cmov",
        descr="conditional move",
        inlineCost=2,
        execCost=1,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=false,
    ),

    LABEL(
        args="id",
        debug="$",
        descr="LLIR label",
        inlineCost=0,
        execCost=0,
        endsFlow=false,
        hasEffect=false,
        volatile=false,
        sideEffect=true   # so that it doesn't get removed by rem unused ops ,
    ),

    GOTO(
        args="id",
        debug="goto",
        descr="LLIR goto label",
        inlineCost=1,
        execCost=2,
        endsFlow=true,
        hasEffect=true,
        volatile=false,
        sideEffect=true,
    ),

    COND(
        args="id, cond: bool",
        debug="cond",
        descr="LLIR conditional goto label",
        inlineCost=1,
        execCost=2,
        endsFlow=false,
        hasEffect=true,
        volatile=false,
        sideEffect=true,
    ),

    CALL(
        args="addr: int / fnref, args...",
        debug="call",
        descr="call function",
        inlineCost=3,
        execCost=3,
        endsFlow=false,
        hasEffect=true ,
        volatile=false ,
        sideEffect=true ,
    ),

    TAILCALL(
        args="addr: int / fnref, args...",
        debug="tailcall",
        descr="call function at end of this fn",
        inlineCost=2,
        execCost=3,
        endsFlow=true,
        hasEffect=true,
        volatile=false,
        sideEffect=true,
    ),

}
